<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>buffer-layout</h1><p><a href="https://www.npmjs.com/package/buffer-layout" title="View this project on NPM"><img src="https://img.shields.io/npm/v/buffer-layout.svg" alt="NPM version"></a>
<a href="https://travis-ci.org/pabigot/buffer-layout" title="Check build status on TravisCI"><img src="https://travis-ci.org/pabigot/buffer-layout.svg?branch=master" alt="Build Status"></a>
<a href="https://coveralls.io/github/pabigot/buffer-layout?branch=master" title="Check coverage status on Coveralls"><img src="https://coveralls.io/repos/pabigot/buffer-layout/badge.svg?branch=master&amp;service=github" alt="Coverage Status"></a></p>
<p>buffer-layout is a utility module implemented in pure JavaScript that
supports translations between JavaScript values and Buffers.  It is made
available through <a href="https://github.com/pabigot/buffer-layout">github</a> and
released under the MIT license.</p>
<p>Layout support is provided for these types of data:</p>
<ul>
<li>Signed and unsigned integral values from 1 to 6 bytes in length, in
little-endian or big-endian format;</li>
<li>Signed and unsigned 64-bit integral values decoded as integral
Numbers;</li>
<li>Float and double values (also little-endian or big-endian);</li>
<li>Sequences of instances of an arbitrary layout, with constant or
data-dependent length;</li>
<li>Structures with named fields containing arbitrary layouts;</li>
<li>Unions of variant layouts where the type of data is recorded in a
prefix value, another layout element, or provided externally;</li>
<li>Bit fields within 8, 16, 24, or 32-bit unsigned integers, numbering
from the least or most significant bit;</li>
<li>NUL-terminated C strings;</li>
<li>Blobs of fixed or variable-length raw data.</li>
</ul>
<h2>Installation</h2><p>Development and testing is done using Node.js, supporting versions 0.12
and later.  Install with <code>npm install buffer-layout</code>.</p>
<h2>Examples</h2><p>All examples are from the <code>test/examples.js</code> unit test and assume the
following context:</p>
<pre class="prettyprint source"><code>var assert = require('assert');
var util = require('util');
var lo = require('buffer-layout');</code></pre><p>The examples give only a taste of what can be done.  Structures, unions,
and sequences can nest; <a href="http://pabigot.github.io/buffer-layout/module-Layout-UnionDiscriminator.html">union
discriminators</a>
can be within the union or external to it; sequence and blob lengths may
be fixed or read from the buffer.</p>
<p>For full details see the <a href="http://pabigot.github.io/buffer-layout/">documentation</a>.</p>
<h3>Four-element array of 16-bit signed little-endian integers</h3><p>The C definition:</p>
<pre class="prettyprint source"><code>int16_t arr[4] = { 1, -1, 3, -3 };</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.seq(lo.s16(), 4);
var b = new Buffer(8);
assert.equal(ds.encode([1, -1, 3, -3], b), 4 * 2);
assert.equal(Buffer('0100ffff0300fdff', 'hex').compare(b), 0);
assert.deepEqual(ds.decode(b), [1, -1, 3, -3]);</code></pre><p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-Int.html">Int</a>
and <a href="http://pabigot.github.io/buffer-layout/module-Layout-Sequence.html">Sequence</a>.</p>
<h3>A native C <code>struct</code> on a 32-bit little-endian machine</h3><p>The C definition:</p>
<pre class="prettyprint source"><code>struct ds {
  uint8_t v;
  uint32_t u32;
} st;</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.struct([lo.u8('v'),
                    lo.seq(lo.u8(), 3), // alignment padding
                    lo.u32('u32')]);
var b = new Buffer(8);
b.fill(0xbd);
assert.equal(ds.encode({v: 1, u32: 0x12345678}, b), 1 + 3 + 4);
assert.equal(Buffer('01bdbdbd78563412', 'hex').compare(b), 0);
assert.deepEqual(ds.decode(b), {v: 1, u32: 0x12345678});</code></pre><p>Note that the C language requires padding which must be explicitly added
in the buffer-layout structure definition.  Since the padding is not
accessible, the corresponding layout has no
<a href="http://pabigot.github.io/buffer-layout/module-Layout-Layout.html#property">property</a>.</p>
<p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-Structure.html">Structure</a>.</p>
<h3>A packed C <code>struct</code> on a 32-bit little-endian machine</h3><p>The C definition:</p>
<pre class="prettyprint source"><code>struct ds {
  uint8_t v;
  uint32_t u32;
} __attribute__((__packed__)) st;</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.struct([lo.u8('v'),
                    lo.u32('u32')]);
var b = new Buffer(5);
b.fill(0xbd);
assert.equal(ds.encode({v: 1, u32: 0x12345678}, b), 1 + 4);
assert.equal(Buffer('0178563412', 'hex').compare(b), 0);
assert.deepEqual(ds.decode(b), {v: 1, u32: 0x12345678});</code></pre><h3>A tagged union of 4-byte values</h3><p>Assume a 5-byte packed structure where the interpretation of the last
four bytes depends on the first byte.  The C definition:</p>
<pre class="prettyprint source"><code>struct {
  uint8_t t;
  union ds {
    uint8_t u8[4];  // default interpretation
    int16_t s16[2]; // when t is 'h'
    uint32_t u32;   // when t is 'w'
    float f32;      // when t is 'f'
  } u;
} __attribute__((__packed__)) un;</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var t = lo.u8('t');
var un = lo.union(t, lo.seq(lo.u8(), 4, 'u8'));
var u32 = un.addVariant('w'.charCodeAt(0), lo.u32(), 'u32');
var s16 = un.addVariant('h'.charCodeAt(0), lo.seq(lo.s16(), 2), 's16');
var f32 = un.addVariant('f'.charCodeAt(0), lo.f32(), 'f32');
var b = new Buffer(un.span);
assert.deepEqual(un.decode(Buffer('7778563412', 'hex')),
                 {u32: 0x12345678});
assert.deepEqual(un.decode(Buffer('660000bd41', 'hex')),
                 {f32: 23.625});
assert.deepEqual(un.decode(Buffer('a5a5a5a5a5', 'hex')),
                 {t: 0xa5, u8: [0xa5, 0xa5, 0xa5, 0xa5]});
assert.equal(s16.encode({s16: [123, -123]}, b), 1 + 2 * 2);
assert.equal(Buffer('687b0085ff', 'hex').compare(b), 0);</code></pre><p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-Union.html">Union</a>.</p>
<h3>Decoding into class instances</h3><p>Using the same 5-byte packet structure but with JavaScript classes
representing the union and the variants:</p>
<pre class="prettyprint source"><code>function Union() { }
lo.bindConstructorLayout(Union,
                         lo.union(lo.u8('t'), lo.seq(lo.u8(), 4, 'u8')));

function Vu32(v) { this.u32 = v; }
util.inherits(Vu32, Union);
lo.bindConstructorLayout(Vu32,
                         Union.layout_.addVariant('w'.charCodeAt(0), lo.u32(), 'u32'));

function Vs16(v) { this.s16 = v; }
util.inherits(Vs16, Union);
lo.bindConstructorLayout(Vs16,
                         Union.layout_.addVariant('h'.charCodeAt(0), lo.seq(lo.s16(), 2), 's16'));

function Vf32(v) { this.f32 = v; }
util.inherits(Vf32, Union);
lo.bindConstructorLayout(Vf32,
                         Union.layout_.addVariant('f'.charCodeAt(0), lo.f32(), 'f32'));

var v = Union.decode(Buffer('7778563412', 'hex'));
assert(v instanceof Vu32);
assert(v instanceof Union);
assert.equal(v.u32, 0x12345678);

v = Union.decode(Buffer('a5a5a5a5a5', 'hex'));
assert(v instanceof Union);
assert.equal(v.t, 0xa5);
assert.deepEqual(v.u8, [0xa5, 0xa5, 0xa5, 0xa5]);

var b = new Buffer(Union.layout_.span);
v = new Vf32(23.625);
v.encode(b);
assert.equal(Buffer('660000bd41', 'hex').compare(b), 0);</code></pre><p>See
<a href="http://pabigot.github.io/buffer-layout/module-Layout-Layout.html#makeDestinationObject">Layout.makeDestinationObject()</a>
and
<a href="http://pabigot.github.io/buffer-layout/module-Layout.html#.bindConstructorLayout">bindConstructorLayout</a>.</p>
<h3>Packed bit fields on a little-endian machine</h3><p>The C definition:</p>
<pre class="prettyprint source"><code>struct ds {
  unsigned int b00l03: 3;
  unsigned int flg03: 1;
  unsigned int b04l18: 24;
  unsigned int b1Cl04: 4;
} st;</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.bits(lo.u32());
var b = new Buffer(4);
ds.addField(3, 'b00l03');
ds.addBoolean('flg03');
ds.addField(24, 'b04l18');
ds.addField(4, 'b1Cl04');
b.fill(0xff);
assert.equal(ds.encode({b00l03: 3, b04l18: 24, b1Cl04: 4}, b), 4);
assert.equal(Buffer('8b010040', 'hex').compare(b), 0);
assert.deepEqual(ds.decode(b),
                 {b00l03: 3, flg03: true, b04l18: 24, b1Cl04: 4});</code></pre><p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-BitStructure.html">BitStructure</a>.</p>
<h3>64-bit values as Numbers</h3><p>The C definition:</p>
<pre class="prettyprint source"><code>uint64_t v = 0x0102030405060708ULL;</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.nu64be();
var b = Buffer('0102030405060708', 'hex');
var v = 72623859790382856;
var nv = v - 6;
assert.equal(v, nv);
assert.equal(ds.decode(b), nv);</code></pre><p>Note that because the exact value is not less than 2^53 it cannot be
represented as a JavaScript Number, and is instead approximated by a
nearby representable integer that is equivalent within Numbers.</p>
<p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-NearUInt64.html">NearUInt64</a>.</p>
<h3>A NUL-terminated C string</h3><p>The C definition:</p>
<pre class="prettyprint source"><code>const char str[] = &quot;hi!&quot;;</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.cstr();
var b = new Buffer(8);
assert.equal(ds.encode('hi!', b), 3 + 1);
var slen = ds.getSpan(b);
assert.equal(slen, 4);
assert.equal(Buffer('68692100', 'hex').compare(b.slice(0, slen)), 0);
assert.equal(ds.decode(b), 'hi!');</code></pre><p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-CString.html">CString</a>.</p>
<h3>A fixed-length block of data offset within a buffer</h3><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var ds = lo.blob(4);
var b = Buffer('0102030405060708', 'hex');
assert.equal(Buffer('03040506', 'hex').compare(ds.decode(b, 2)), 0);</code></pre><p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-Blob.html">Blob</a>.</p>
<h3>A variable-length array of pairs of C strings</h3><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var pr = lo.seq(lo.cstr(), 2);
var n = lo.u8('n');
var vla = lo.seq(pr, lo.offset(n, -1), 'a');
var st = lo.struct([n, vla], 'st');
var b = new Buffer(32);
var arr = [['k1', 'v1'], ['k2', 'v2'], ['k3', 'etc']];
b.fill(0);
assert.equal(st.encode({a: arr}, b), 1 + (2 * ((2 + 1) + (2 + 1)) + (2 + 1) + (3 + 1)));
var span = st.getSpan(b);
assert.equal(span, 20);
assert.equal(Buffer('036b31007631006b32007632006b330065746300', 'hex')
             .compare(b.slice(0, span)), 0);
assert.deepEqual(st.decode(b), {n: 3, a: arr});</code></pre><p>See <a href="http://pabigot.github.io/buffer-layout/module-Layout-OffsetLayout.html">OffsetLayout</a>.</p>
<h3>A C flexible array member with implicit length</h3><p>When data is obtained over a packetized interface the length of the
packet can provide implicit limits on the last field.</p>
<p>The C definition:</p>
<pre class="prettyprint source"><code>struct ds {
  uint8_t prop;
  uint16_t data[];
};</code></pre><p>The buffer-layout way:</p>
<pre class="prettyprint source"><code>var st = lo.struct([lo.u8('prop'),
                    lo.seq(lo.u16(),
                           lo.greedy(lo.u16().span),
                           'data')],
                   'ds');
var b = Buffer('21010002030405', 'hex');
assert.deepEqual(st.decode(b), {prop: 33, data: [0x0001, 0x0302, 0x0504]});
b.fill(0xFF);
assert.equal(st.encode({prop: 9, data: [5,6]}, b), 1 + 2 * 2);
assert.equal(Buffer('0905000600FFFF', 'hex').compare(b), 0);</code></pre><h3>Tagged values, or variable-length unions</h3><p>Storing arbitrary data using a leading byte to identify the content then
a value that takes up only as much room as is necessary.</p>
<p>The example also shows how to extend the variant recognition API to
support abitrary constant without consuming space for them in the
encoded union.  This could be used to make something similar to
<a href="http://bsonspec.org/spec.html">BSON</a>.</p>
<p>Here's the code that defines the union, the variants, and the
recognition of <code>true</code> and <code>false</code> values for <code>b</code> as distinct variants:</p>
<pre class="prettyprint source"><code>var un = lo.union(lo.u8('t'));
var u8 = un.addVariant('B'.charCodeAt(0), lo.u8(), 'u8');
var s16 = un.addVariant('h'.charCodeAt(0), lo.s16(), 's16');
var s48 = un.addVariant('Q'.charCodeAt(0), lo.s48(), 's48');
var cstr = un.addVariant('s'.charCodeAt(0), lo.cstr(), 'str');
var tr = un.addVariant('T'.charCodeAt(0), lo.const(true), 'b');
var fa = un.addVariant('F'.charCodeAt(0), lo.const(false), 'b');
var b = new Buffer(1 + 6);
un.configGetSourceVariant(function(src) {
  if (src.hasOwnProperty('b')) {
    return src.b ? tr : fa;
  }
  return this.defaultGetSourceVariant(src);
});</code></pre><p>And here are examples of encoding, checking the encoded length, and
decoding each of the alternatives:</p>
<pre class="prettyprint source"><code>b.fill(0xff);
assert.equal(un.encode({u8: 1}, b), 1 + 1);
assert.equal(un.getSpan(b), 2);
assert.equal(Buffer('4201ffffffffff', 'hex').compare(b), 0);
assert.equal(un.decode(b).u8, 1);

b.fill(0xff);
assert.equal(un.encode({s16: -32000}, b), 1 + 2);
assert.equal(un.getSpan(b), 3);
assert.equal(Buffer('680083ffffffff', 'hex').compare(b), 0);
assert.equal(un.decode(b).s16, -32000);

b.fill(0xff);
var v48 = Math.pow(2, 47) - 1;
assert.equal(un.encode({s48: v48}, b), 1 + 6);
assert.equal(un.getSpan(b), 7);
assert.equal(Buffer('51ffffffffff7f', 'hex').compare(b), 0);
assert.equal(un.decode(b).s48, v48);

b.fill(0xff);
assert.equal(un.encode({b: true}, b), 1);
assert.equal(un.getSpan(b), 1);
assert.equal(Buffer('54ffffffffffff', 'hex').compare(b), 0);
assert.strictEqual(un.decode(b).b, true);

b.fill(0xff);
assert.equal(un.encode({b: false}, b), 1);
assert.equal(un.getSpan(b), 1);
assert.equal(Buffer('46ffffffffffff', 'hex').compare(b), 0);
assert.strictEqual(un.decode(b).b, false);</code></pre><p><strong>NOTE</strong> This code tickles a long-standing <a href="https://github.com/nodejs/node/pull/3994">bug in
Buffer.writeInt{L,B}E</a>. <code>buffer-layout</code>
provides a <a href="http://pabigot.github.io/buffer-layout/module-patchIssue3992.html">module that patches
<code>Buffer</code></a>
to fix the bug if it detects that the running Node has the error.</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Layout.html">Layout</a></li><li><a href="module-patchIssue3992.html">patchIssue3992</a></li></ul><h3>Classes</h3><ul><li><a href="module-Layout-BitField.html">BitField</a></li><li><a href="module-Layout-BitStructure.html">BitStructure</a></li><li><a href="module-Layout-Blob.html">Blob</a></li><li><a href="module-Layout-Boolean.html">Boolean</a></li><li><a href="module-Layout-Constant.html">Constant</a></li><li><a href="module-Layout-CString.html">CString</a></li><li><a href="module-Layout-Double.html">Double</a></li><li><a href="module-Layout-DoubleBE.html">DoubleBE</a></li><li><a href="module-Layout-ExternalLayout.html">ExternalLayout</a></li><li><a href="module-Layout-Float.html">Float</a></li><li><a href="module-Layout-FloatBE.html">FloatBE</a></li><li><a href="module-Layout-GreedyCount.html">GreedyCount</a></li><li><a href="module-Layout-Int.html">Int</a></li><li><a href="module-Layout-IntBE.html">IntBE</a></li><li><a href="module-Layout-Layout.html">Layout</a></li><li><a href="module-Layout-NearInt64.html">NearInt64</a></li><li><a href="module-Layout-NearInt64BE.html">NearInt64BE</a></li><li><a href="module-Layout-NearUInt64.html">NearUInt64</a></li><li><a href="module-Layout-NearUInt64BE.html">NearUInt64BE</a></li><li><a href="module-Layout-OffsetLayout.html">OffsetLayout</a></li><li><a href="module-Layout-Sequence.html">Sequence</a></li><li><a href="module-Layout-Structure.html">Structure</a></li><li><a href="module-Layout-UInt.html">UInt</a></li><li><a href="module-Layout-UIntBE.html">UIntBE</a></li><li><a href="module-Layout-Union.html">Union</a></li><li><a href="module-Layout-UnionDiscriminator.html">UnionDiscriminator</a></li><li><a href="module-Layout-UnionLayoutDiscriminator.html">UnionLayoutDiscriminator</a></li><li><a href="module-Layout-VariantLayout.html">VariantLayout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Tue Mar 08 2016 07:26:24 GMT-0600 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>